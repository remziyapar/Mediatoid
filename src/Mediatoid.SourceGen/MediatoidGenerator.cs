using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Mediatoid.SourceGen;

/// <summary>
/// Mediatoid için derleme zamanında handler kayıtlarını üreten source generator.
/// IRequestHandler, INotificationHandler ve IStreamRequestHandler implementasyonlarını bulur ve kayıt tablosu üretir.
/// </summary>
[Generator]
public sealed class MediatoidGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Incremental generator başlatıcısı. Sembol adaylarını toplayıp kayıt tablosu kodunu üretir.
    /// </summary>
    /// <param name="context">Başlatma bağlamı.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Sadece interface/base list içeren sınıfları aday olarak seç.
        var classSymbols = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax cds && cds.BaseList is not null,
                static (ctx, _) => (INamedTypeSymbol?)ctx.SemanticModel.GetDeclaredSymbol((ClassDeclarationSyntax)ctx.Node))
            .Where(static s => s is not null)
            .Select(static (s, _) => s!);

        var collected = classSymbols.Collect();

        context.RegisterSourceOutput(collected, static (spc, classes) =>
        {
            // Aynı kayıt tekrarını önlemek için set.
            var emitted = new HashSet<(string Service, string Impl)>(StringTupleComparer.Instance);

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("namespace Mediatoid.Generated;");
            sb.AppendLine();
            sb.AppendLine("internal static class MediatoidGeneratedRegistry");
            sb.AppendLine("{");
            sb.AppendLine("    internal static readonly RegistrationDescriptor[] Maps = new RegistrationDescriptor[]");
            sb.AppendLine("    {");

            foreach (var cls in classes)
            {
                if (cls.IsAbstract) continue;

                foreach (var iface in cls.AllInterfaces)
                {
                    if (!iface.IsGenericType) continue;

                    var def = iface.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var implFull = cls.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    if (def == "global::Mediatoid.IRequestHandler<,>")
                    {
                        var req = iface.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var res = iface.TypeArguments[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var service = $"typeof(global::Mediatoid.IRequestHandler<{req}, {res}>)";
                        if (emitted.Add((service, implFull)))
                            sb.AppendLine($"        new RegistrationDescriptor({service}, typeof({implFull})),");
                    }
                    else if (def == "global::Mediatoid.INotificationHandler<>")
                    {
                        var notif = iface.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var service = $"typeof(global::Mediatoid.INotificationHandler<{notif}>)";
                        if (emitted.Add((service, implFull)))
                            sb.AppendLine($"        new RegistrationDescriptor({service}, typeof({implFull})),");
                    }
                    else if (def == "global::Mediatoid.IStreamRequestHandler<,>")
                    {
                        var req = iface.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var item = iface.TypeArguments[1].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var service = $"typeof(global::Mediatoid.IStreamRequestHandler<{req}, {item}>)";
                        if (emitted.Add((service, implFull)))
                            sb.AppendLine($"        new RegistrationDescriptor({service}, typeof({implFull})),");
                    }
                }
            }

            sb.AppendLine("    };");
            sb.AppendLine("}");
            sb.AppendLine();
            sb.AppendLine("internal readonly struct RegistrationDescriptor");
            sb.AppendLine("{");
            sb.AppendLine("    public readonly Type Service;");
            sb.AppendLine("    public readonly Type Implementation;");
            sb.AppendLine("    public RegistrationDescriptor(Type service, Type implementation)");
            sb.AppendLine("    {");
            sb.AppendLine("        Service = service;");
            sb.AppendLine("        Implementation = implementation;");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            spc.AddSource("MediatoidGeneratedRegistry.g.cs", sb.ToString());
        });
    }

    // Jeneratör derlemesinde kullanılan tuple comparer (üretilen koda eklenmez).
    private sealed class StringTupleComparer : IEqualityComparer<(string Service, string Impl)>
    {
        internal static readonly StringTupleComparer Instance = new();

        public bool Equals((string Service, string Impl) x, (string Service, string Impl) y)
            => StringComparer.Ordinal.Equals(x.Service, y.Service)
               && StringComparer.Ordinal.Equals(x.Impl, y.Impl);

        public int GetHashCode((string Service, string Impl) obj)
            => HashCode.Combine(
                StringComparer.Ordinal.GetHashCode(obj.Service),
                StringComparer.Ordinal.GetHashCode(obj.Impl));
    }
}
