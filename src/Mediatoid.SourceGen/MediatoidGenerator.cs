using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;
using System.Linq;
using System.Collections.Generic;

namespace Mediatoid.SourceGen;

/// <summary>
/// Mediatoid için derleme zamanında handler kayıtlarını ve (root işaretlenmişse) tam request pipeline invoker sınıflarını üreten
/// incremental source generator. Amaç: runtime reflection + davranış zinciri compose maliyetini düşürmek (Stage 2).
/// </summary>
[Generator]
public sealed class MediatoidGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Roslyn incremental pipeline yapılandırması: handler / behavior sınıflarını toplar, ilişkileri analiz eder ve
    /// hızlı dispatch + pipeline invoker kaynak kodunu üretir. Duplicate / geçersiz durumlar için tanısal (diagnostic) kayıtlar ekler.
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classSymbols = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax cds && cds.BaseList is not null,
                static (ctx, _) => (INamedTypeSymbol?)ctx.SemanticModel.GetDeclaredSymbol((ClassDeclarationSyntax)ctx.Node))
            .Where(static s => s is not null)
            .Select(static (s, _) => s!);

        var compilationProvider = context.CompilationProvider;

        context.RegisterSourceOutput(classSymbols.Collect().Combine(compilationProvider), static (spc, tuple) =>
        {
            var (classes, compilation) = tuple;

            var rootAttrSym = compilation.GetTypeByMetadataName("Mediatoid.MediatoidRootAttribute")
                                 ?? compilation.GetTypeByMetadataName("Mediatoid.SourceGen.MediatoidRootAttribute");
            var iReqHandlerDef = compilation.GetTypeByMetadataName("Mediatoid.IRequestHandler`2");
            var iNotifHandlerDef = compilation.GetTypeByMetadataName("Mediatoid.INotificationHandler`1");
            var iStreamHandlerDef = compilation.GetTypeByMetadataName("Mediatoid.IStreamRequestHandler`2");
            var iBehaviorDef = compilation.GetTypeByMetadataName("Mediatoid.Pipeline.IPipelineBehavior`2");

            var rootAttr = rootAttrSym is not null
                ? compilation.Assembly.GetAttributes().FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, rootAttrSym))
                : null;

            bool isRoot = rootAttr is not null;

            var assemblyOrder = new List<IAssemblySymbol>();
            if (rootAttr is not null && rootAttr.ConstructorArguments.Length > 0 && rootAttr.ConstructorArguments[0].Values is { Length: > 0 } vals)
            {
                foreach (var v in vals)
                {
                    if (v.Value is INamedTypeSymbol nts)
                    {
                        var asm = nts.ContainingAssembly;
                        if (assemblyOrder.All(a => !SymbolEqualityComparer.Default.Equals(a, asm)))
                            assemblyOrder.Add(asm);
                    }
                }
            }
            if (assemblyOrder.Count == 0)
                assemblyOrder.Add(compilation.Assembly);

            var duplicateHandlerMap = new Dictionary<(INamedTypeSymbol Req, INamedTypeSymbol Res), List<INamedTypeSymbol>>(SymbolPairComparer.Instance);
            var invalidBehaviorList = new List<INamedTypeSymbol>();
            var emitted = new HashSet<(string Service, string Impl)>(StringTupleComparer.Instance);

            var sb = new StringBuilder(16_000);
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("// Stage 2: Handler + Pipeline (behaviors dahil) — optimized dispatch & unrolled continuation.");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using System.Threading;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine("using Mediatoid.Pipeline;");
            sb.AppendLine("namespace Mediatoid.Generated;");
            sb.AppendLine();

            sb.AppendLine("internal static class MediatoidGeneratedRegistry");
            sb.AppendLine("{");
            sb.AppendLine("    internal static readonly RegistrationDescriptor[] Maps = new RegistrationDescriptor[]");
            sb.AppendLine("    {");

            var handlerPairs = new List<(INamedTypeSymbol Req, INamedTypeSymbol Res, INamedTypeSymbol HandlerImpl)>();
            var allBehaviorImpls = new List<INamedTypeSymbol>();
            var closedBehaviorMap = new Dictionary<(INamedTypeSymbol Req, INamedTypeSymbol Res), List<INamedTypeSymbol>>(SymbolPairComparer.Instance);

            foreach (var cls in classes)
            {
                if (cls.IsAbstract) continue;
                bool isBehaviorImpl = false;

                foreach (var iface in cls.AllInterfaces)
                {
                    if (!iface.IsGenericType) continue;

                    if (iReqHandlerDef is not null && SymbolEqualityComparer.Default.Equals(iface.OriginalDefinition, iReqHandlerDef))
                    {
                        if (iface.TypeArguments[0] is INamedTypeSymbol reqSym &&
                            iface.TypeArguments[1] is INamedTypeSymbol resSym)
                        {
                            var reqStr = reqSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var resStr = resSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var implStr = cls.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var service = $"typeof(global::Mediatoid.IRequestHandler<{reqStr}, {resStr}>)";
                            if (emitted.Add((service, implStr)))
                                sb.AppendLine($"        new RegistrationDescriptor({service}, typeof({implStr})),");
                            handlerPairs.Add((reqSym, resSym, cls));

                            var key = (reqSym, resSym);
                            if (!duplicateHandlerMap.TryGetValue(key, out var list))
                                duplicateHandlerMap[key] = list = new List<INamedTypeSymbol>();
                            list.Add(cls);
                        }
                    }
                    else if (iNotifHandlerDef is not null && SymbolEqualityComparer.Default.Equals(iface.OriginalDefinition, iNotifHandlerDef))
                    {
                        if (iface.TypeArguments[0] is INamedTypeSymbol notifSym)
                        {
                            var notifStr = notifSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var implStr = cls.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var service = $"typeof(global::Mediatoid.INotificationHandler<{notifStr}>)";
                            if (emitted.Add((service, implStr)))
                                sb.AppendLine($"        new RegistrationDescriptor({service}, typeof({implStr})),");
                        }
                    }
                    else if (iStreamHandlerDef is not null && SymbolEqualityComparer.Default.Equals(iface.OriginalDefinition, iStreamHandlerDef))
                    {
                        if (iface.TypeArguments[0] is INamedTypeSymbol reqSym &&
                            iface.TypeArguments[1] is INamedTypeSymbol itemSym)
                        {
                            var reqStr = reqSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var itemStr = itemSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var implStr = cls.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var service = $"typeof(global::Mediatoid.IStreamRequestHandler<{reqStr}, {itemStr}>)";
                            if (emitted.Add((service, implStr)))
                                sb.AppendLine($"        new RegistrationDescriptor({service}, typeof({implStr})),");
                        }
                    }
                    else if (iBehaviorDef is not null && SymbolEqualityComparer.Default.Equals(iface.OriginalDefinition, iBehaviorDef))
                    {
                        isBehaviorImpl = true;
                        bool openGeneric = cls.IsGenericType &&
                                           cls.TypeParameters.Length == 2 &&
                                           iface.TypeArguments[0] is ITypeParameterSymbol &&
                                           iface.TypeArguments[1] is ITypeParameterSymbol;

                        if (openGeneric)
                        {
                            if (!allBehaviorImpls.Contains(cls.OriginalDefinition))
                                allBehaviorImpls.Add(cls.OriginalDefinition);
                        }
                        else
                        {
                            if (iface.TypeArguments[0] is INamedTypeSymbol reqSym2 &&
                                iface.TypeArguments[1] is INamedTypeSymbol resSym2)
                            {
                                var key = (reqSym2, resSym2);
                                if (!closedBehaviorMap.TryGetValue(key, out var list))
                                    closedBehaviorMap[key] = list = new List<INamedTypeSymbol>();
                                if (!list.Contains(cls))
                                    list.Add(cls);
                            }
                            else
                            {
                                invalidBehaviorList.Add(cls);
                            }
                        }
                    }
                }

                if (isBehaviorImpl && !cls.IsGenericType)
                {
                    if (!allBehaviorImpls.Contains(cls))
                        allBehaviorImpls.Add(cls);
                }
            }

            sb.AppendLine("    };");
            sb.AppendLine("}");

            if (isRoot && handlerPairs.Count > 0)
            {
                sb.AppendLine();
                sb.AppendLine("/// <summary>Build-time üretilen request pipeline invoker (handler + behavior zinciri).</summary>");

                var distinctHandlerPairs = handlerPairs
                    .GroupBy(h => (h.Req, h.Res), SymbolPairComparer.Instance)
                    .SelectMany(g => g.OrderBy(x => x.HandlerImpl.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal).Take(1));

                foreach (var (reqSym, resSym, handlerImpl) in distinctHandlerPairs)
                {
                    var reqType = reqSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var resType = resSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var handlerType = handlerImpl.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var sanitizedReq = Sanitize(reqType);
                    var sanitizedRes = Sanitize(resType);
                    var sanitizedHandler = Sanitize(handlerType);

                    var behaviorCandidates = new List<INamedTypeSymbol>();
                    if (closedBehaviorMap.TryGetValue((reqSym, resSym), out var closedList))
                        behaviorCandidates.AddRange(closedList);

                    foreach (var b in allBehaviorImpls.Where(b => b.IsGenericType && b.TypeParameters.Length == 2))
                        if (!behaviorCandidates.Contains(b))
                            behaviorCandidates.Add(b);

                    // İlk iki aşama zaten önce concrete sonra generic definition bazında deduplikasyon yapıyor.
                    if (behaviorCandidates.Count > 1)
                    {
                        var concreteSeen = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
                        var tmp = new List<INamedTypeSymbol>();
                        foreach (var b in behaviorCandidates)
                            if (concreteSeen.Add(b))
                                tmp.Add(b);
                        behaviorCandidates = tmp;

                        var genSeen = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
                        tmp = new List<INamedTypeSymbol>();
                        foreach (var b in behaviorCandidates)
                        {
                            var key = b.IsGenericType ? b.OriginalDefinition : b;
                            if (genSeen.Add(key))
                                tmp.Add(b);
                        }
                        behaviorCandidates = tmp;
                    }

                    // Güçlendirilmiş birleşik dedup: hem concrete hem generic definition tekrarı kesin temizlenir.
                    if (behaviorCandidates.Count > 1)
                    {
                        var unique = new List<INamedTypeSymbol>(behaviorCandidates.Count);
                        var seenConcrete = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
                        var seenGenDef = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

                        foreach (var b in behaviorCandidates)
                        {
                            var genKey = b.IsGenericType ? b.OriginalDefinition : b;
                            if (seenGenDef.Contains(genKey)) continue;
                            if (!seenConcrete.Add(b)) continue;
                            unique.Add(b);
                            seenGenDef.Add(genKey);
                        }
                        behaviorCandidates = unique;
                    }

                    behaviorCandidates = behaviorCandidates
                        .OrderBy(b => GetAssemblyIndex(b.ContainingAssembly, assemblyOrder))
                        .ThenBy(b => b.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal)
                        .ToList();

                    if (behaviorCandidates.Count > 0)
                    {
                        sb.AppendLine($"// Behaviors (outer->inner) for {reqType} -> {resType}:");
                        foreach (var beh in behaviorCandidates)
                        {
                            if (beh.IsGenericType && beh.TypeParameters.Length == 2)
                                sb.AppendLine($"//   {beh.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Split('<')[0]}<{reqType}, {resType}>");
                            else
                                sb.AppendLine($"//   {beh.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}");
                        }
                    }

                    sb.AppendLine($"internal static class Pipeline_{sanitizedReq}_{sanitizedRes}_{sanitizedHandler}");
                    sb.AppendLine("{");
                    sb.AppendLine($"    private static IPipelineBehavior<{reqType}, {resType}> Resolve(IServiceProvider sp, Type t)");
                    sb.AppendLine("    {");
                    sb.AppendLine($"        return (IPipelineBehavior<{reqType}, {resType}>)(sp.GetService(t) ?? Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateInstance(sp, t));");
                    sb.AppendLine("    }");
                    sb.AppendLine();
                    sb.AppendLine($"    internal static ValueTask<{resType}> Invoke({reqType} request, IServiceProvider sp, CancellationToken ct)");
                    sb.AppendLine("    {");
                    sb.AppendLine($"        var handler = sp.GetRequiredService<{handlerType}>();");
                    sb.AppendLine($"        var list = new List<IPipelineBehavior<{reqType}, {resType}>>({behaviorCandidates.Count});");

                    foreach (var beh in behaviorCandidates)
                    {
                        if (beh.IsGenericType && beh.TypeParameters.Length == 2)
                        {
                            var behOpenStr = ToOpenGenericTypeSyntax(beh);
                            sb.AppendLine("        {");
                            sb.AppendLine($"            var t = typeof({behOpenStr}).MakeGenericType(typeof({reqType}), typeof({resType}));");
                            sb.AppendLine("            list.Add(Resolve(sp, t));");
                            sb.AppendLine("        }");
                        }
                        else
                        {
                            var behTypeStr = beh.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            sb.AppendLine($"        list.Add(Resolve(sp, typeof({behTypeStr})));");
                        }
                    }

                    sb.AppendLine("        if (list.Count == 0) return handler.Handle(request, ct);");
                    sb.AppendLine("        var behaviors = list.ToArray();");
                    sb.AppendLine($"        if (behaviors.Length == 1) return behaviors[0].Handle(request, () => handler.Handle(request, ct), ct);");
                    sb.AppendLine($"        if (behaviors.Length == 2) return behaviors[0].Handle(request, () => behaviors[1].Handle(request, () => handler.Handle(request, ct), ct), ct);");
                    sb.AppendLine("        int index = 0;");
                    sb.AppendLine($"        ValueTask<{resType}> Next()");
                    sb.AppendLine("        {");
                    sb.AppendLine("            if (index >= behaviors.Length)");
                    sb.AppendLine($"                return handler.Handle(request, ct);");
                    sb.AppendLine("            var current = behaviors[index++];");
                    sb.AppendLine("            return current.Handle(request, Next, ct);");
                    sb.AppendLine("        }");
                    sb.AppendLine("        return Next();");
                    sb.AppendLine("    }");
                    sb.AppendLine("}");
                    sb.AppendLine();
                }
            }

            // Statik dispatch tipini üret (XML doküman eklendi)
            sb.AppendLine("/// <summary>");
            sb.AppendLine("/// Source generator tarafından üretilen statik hızlı dispatch giriş noktası. Handler + pipeline invoker grafiklerini");
            sb.AppendLine("/// build-time analizine göre kullanarak çalışma zamanında compose maliyetini azaltır. Root attribute yoksa başarısız döner.");
            sb.AppendLine("/// </summary>");
            sb.AppendLine("public static class MediatoidGeneratedDispatch");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Üretilmiş dispatch haritasını kullanarak isteği hızlı yoldan yürütür. Başarılı olduğunda compose işlemi (behavior zinciri + handler delegeleri)");
            sb.AppendLine("    /// önceden oluşturulmuş invoker üzerinden çalışır; aksi halde <c>Success=false</c> döner ve çağıran runtime fallback'e geçebilir.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    /// <typeparam name=\"TResponse\">İstek yanıt tipi.</typeparam>");
            sb.AppendLine("    /// <param name=\"request\">Gönderilen IRequest örneği.</param>");
            sb.AppendLine("    /// <param name=\"sp\">Servis sağlayıcı (DI konteyner).</param>");
            sb.AppendLine("    /// <param name=\"ct\">İptal belirteci.</param>");
            sb.AppendLine("    /// <returns><c>Success=true</c> ise <c>Result</c> hızlı yol ValueTask'i; değilse default.</returns>");
            sb.AppendLine("    public static (bool Success, ValueTask<TResponse> Result) TryInvoke<TResponse>(global::Mediatoid.IRequest<TResponse> request, IServiceProvider sp, CancellationToken ct)");
            sb.AppendLine("    {");
            if (isRoot && handlerPairs.Count > 0)
            {
                foreach (var grp in handlerPairs.GroupBy(p => p.Res, SymbolEqualityComparer.Default))
                {
                    var resSym = grp.Key;
                    if (resSym is null) continue;
                    var resTypeFull = resSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var sanitizedRes = Sanitize(resTypeFull);

                    sb.AppendLine($"        if (typeof(TResponse) == typeof({resTypeFull}))");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            if (Dispatch_{sanitizedRes}.Try(request, sp, ct, out var vt))");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                var tmp = vt; // ValueTask<{resTypeFull}>");
                    sb.AppendLine($"                var cast = Unsafe.As<ValueTask<{resTypeFull}>, ValueTask<TResponse>>(ref tmp);");
                    sb.AppendLine("                return (true, cast);");
                    sb.AppendLine("            }");
                    sb.AppendLine("        }");
                }
                sb.AppendLine("        return (false, default);");
            }
            else
            {
                sb.AppendLine("        return (false, default);");
            }
            sb.AppendLine("    }");
            sb.AppendLine("}");

            if (isRoot && handlerPairs.Count > 0)
            {
                foreach (var grp in handlerPairs.GroupBy(p => p.Res, SymbolEqualityComparer.Default))
                {
                    var resSym = grp.Key;
                    if (resSym is null) continue;
                    var resTypeFull = resSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var sanitizedRes = Sanitize(resTypeFull);

                    sb.AppendLine($"internal static class Dispatch_{sanitizedRes}");
                    sb.AppendLine("{");
                    sb.AppendLine($"    private static readonly Dictionary<Type, Func<object, IServiceProvider, CancellationToken, ValueTask<{resTypeFull}>>> _map = new()");
                    sb.AppendLine("    {");
                    var addedReqTypes = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
                    foreach (var pair in grp
                             .OrderBy(p => p.Req.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
                    {
                        if (!addedReqTypes.Add(pair.Req)) continue;

                        var reqFull = pair.Req.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var handlerFull = pair.HandlerImpl.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var sanitizedReq = Sanitize(reqFull);
                        var sanitizedHandler = Sanitize(handlerFull);

                        sb.AppendLine($"        [typeof({reqFull})] = static (req, sp, ct) => Pipeline_{sanitizedReq}_{sanitizedRes}_{sanitizedHandler}.Invoke(({reqFull})req, sp, ct),");
                    }
                    sb.AppendLine("    };");
                    sb.AppendLine();
                    sb.AppendLine($"    internal static bool Try<TResponse>(global::Mediatoid.IRequest<TResponse> request, IServiceProvider sp, CancellationToken ct, out ValueTask<{resTypeFull}> result)");
                    sb.AppendLine("    {");
                    sb.AppendLine("        var type = request.GetType();");
                    sb.AppendLine("        if (_map.TryGetValue(type, out var inv))");
                    sb.AppendLine("        {");
                    sb.AppendLine("            result = inv(request, sp, ct);");
                    sb.AppendLine("            return true;");
                    sb.AppendLine("        }");
                    sb.AppendLine("        result = default;");
                    sb.AppendLine("        return false;");
                    sb.AppendLine("    }");
                    sb.AppendLine("}");
                }
            }

            sb.AppendLine();
            sb.AppendLine("internal readonly struct RegistrationDescriptor");
            sb.AppendLine("{");
            sb.AppendLine("    public readonly Type Service;");
            sb.AppendLine("    public readonly Type Implementation;");
            sb.AppendLine("    public RegistrationDescriptor(Type service, Type implementation)");
            sb.AppendLine("    {");
            sb.AppendLine("        Service = service;");
            sb.AppendLine("        Implementation = implementation;");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            spc.AddSource("MediatoidGeneratedRegistry.g.cs", sb.ToString());

            if (!isRoot)
                spc.ReportDiagnostic(Diagnostic.Create(Diagnostics.MissingRootAttribute, Location.None));

            foreach (var kv in duplicateHandlerMap.Where(kv => kv.Value.Count > 1))
            {
                var (req, res) = kv.Key;
                var reqStr = req.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var resStr = res.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var all = string.Join(", ", kv.Value.Select(h => h.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
                foreach (var impl in kv.Value)
                {
                    spc.ReportDiagnostic(Diagnostic.Create(Diagnostics.DuplicateHandler,
                        impl.Locations.FirstOrDefault() ?? Location.None,
                        reqStr, resStr, all));
                }
            }

            foreach (var beh in invalidBehaviorList)
                spc.ReportDiagnostic(Diagnostic.Create(Diagnostics.InvalidBehaviorArity,
                    beh.Locations.FirstOrDefault() ?? Location.None,
                    beh.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
        });
    }

    private static int GetAssemblyIndex(IAssemblySymbol asm, List<IAssemblySymbol> order)
    {
        for (int i = 0; i < order.Count; i++)
            if (SymbolEqualityComparer.Default.Equals(order[i], asm))
                return i;
        return int.MaxValue;
    }

    private static string Sanitize(string full)
    {
        var trimmed = full.StartsWith("global::", System.StringComparison.Ordinal) ? full["global::".Length..] : full;
        Span<uint> hashSpan = stackalloc uint[1];
        hashSpan[0] = 2166136261;
        foreach (var ch in trimmed)
        {
            hashSpan[0] ^= ch;
            hashSpan[0] *= 16777619;
        }
        var basePart = new string(trimmed.Select(c => char.IsLetterOrDigit(c) ? c : '_').ToArray());
        return $"{basePart}_{hashSpan[0]:x8}";
    }

    private static string ToOpenGenericTypeSyntax(INamedTypeSymbol genericType)
    {
        var open = genericType.OriginalDefinition;
        var full = open.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var lt = full.IndexOf('<');
        if (lt >= 0)
        {
            var head = full[..lt];
            var commas = new string(',', open.Arity - 1);
            return $"{head}<{commas}>";
        }
        if (open.Arity > 0)
        {
            var commas = new string(',', open.Arity - 1);
            return $"{full}<{commas}>";
        }
        return full;
    }

    private static class Diagnostics
    {
        internal static readonly DiagnosticDescriptor MissingRootAttribute = new(
            "MDT001",
            "MediatoidRootAttribute eksik",
            "Pipeline invoker üretimi için assembly seviyesinde [MediatoidRoot] eklenmesi önerilir",
            "Mediatoid.SourceGen",
            DiagnosticSeverity.Info,
            true);

        internal static readonly DiagnosticDescriptor DuplicateHandler = new(
            "MDT002",
            "Çakışan request handler",
            "Aynı IRequest<{0},{1}> için birden fazla handler tanımlı: {2}",
            "Mediatoid.SourceGen",
            DiagnosticSeverity.Error,
            true);

        internal static readonly DiagnosticDescriptor InvalidBehaviorArity = new(
            "MDT003",
            "Geçersiz pipeline behavior generic arity",
            "IPipelineBehavior implementasyonu open generic (TRequest, TResponse) veya closed generic olmalıdır. Kısmen kapalı implementasyonlar desteklenmez: {0}.",
            "Mediatoid.SourceGen",
            DiagnosticSeverity.Warning,
            true);
    }

    private sealed class StringTupleComparer : IEqualityComparer<(string Service, string Impl)>
    {
        internal static readonly StringTupleComparer Instance = new();
        public bool Equals((string Service, string Impl) x, (string Service, string Impl) y)
            => System.StringComparer.Ordinal.Equals(x.Service, y.Service) &&
               System.StringComparer.Ordinal.Equals(x.Impl, y.Impl);
        public int GetHashCode((string Service, string Impl) obj)
            => System.HashCode.Combine(
                System.StringComparer.Ordinal.GetHashCode(obj.Service),
                System.StringComparer.Ordinal.GetHashCode(obj.Impl));
    }

    private sealed class SymbolPairComparer : IEqualityComparer<(INamedTypeSymbol Req, INamedTypeSymbol Res)>
    {
        internal static readonly SymbolPairComparer Instance = new();
        public bool Equals((INamedTypeSymbol Req, INamedTypeSymbol Res) x, (INamedTypeSymbol Req, INamedTypeSymbol Res) y)
            => SymbolEqualityComparer.Default.Equals(x.Req, y.Req) &&
               SymbolEqualityComparer.Default.Equals(x.Res, y.Res);
        public int GetHashCode((INamedTypeSymbol Req, INamedTypeSymbol Res) obj)
            => System.HashCode.Combine(
                SymbolEqualityComparer.Default.GetHashCode(obj.Req),
                SymbolEqualityComparer.Default.GetHashCode(obj.Res));
    }

    private sealed class NamedTypeSymbolComparer : IEqualityComparer<INamedTypeSymbol>
    {
        internal static readonly NamedTypeSymbolComparer Instance = new();
        public bool Equals(INamedTypeSymbol? x, INamedTypeSymbol? y) => SymbolEqualityComparer.Default.Equals(x, y);
        public int GetHashCode(INamedTypeSymbol obj) => SymbolEqualityComparer.Default.GetHashCode(obj);
    }
}
